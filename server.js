import express from 'express';
import { GoogleGenAI, Type } from "@google/genai";

// --- SERVER SETUP ---
const app = express();
const port = process.env.PORT || 3000;

// --- CORS MIDDLEWARE ---
// This is crucial for allowing your frontend (hosted on a different domain like GitHub Pages)
// to communicate with this backend server. It tells the browser that requests from any origin are allowed.
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*'); // Allow any domain
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS'); // Allow these methods
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Accept'); // Allow these headers

  // Handle the browser's preflight 'OPTIONS' request for CORS
  if (req.method === 'OPTIONS') {
    return res.status(204).end();
  }

  next();
});

app.use(express.json({ limit: '50mb' }));

// --- GEMINI API SETUP ---
const API_KEY = process.env.API_KEY;
if (!API_KEY) {
  console.error("FATAL ERROR: API_KEY environment variable is not set.");
  process.exit(1);
}
const ai = new GoogleGenAI({ apiKey: API_KEY });
const model = "gemini-2.5-flash";

// --- API HELPER ---
const sendError = (res, message, status = 500) => {
    console.error(`API Error: ${message}`);
    res.status(status).json({ error: message });
};

// --- API ENDPOINTS ---

/**
 * Main streaming chat endpoint.
 */
app.post('/api/chat', async (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.flushHeaders();

    try {
        const { history, persona, isWebAccessEnabled, isCostSaverMode, isDeepAnalysis, customInstruction, modelParams } = req.body;
        const systemInstruction = generateSystemInstruction(persona, isWebAccessEnabled, isCostSaverMode, isDeepAnalysis, customInstruction);
        const contents = history.map(msg => ({
            role: msg.role === 'assistant' ? 'model' : msg.role,
            parts: [{ text: msg.text }], // Simplified for this example
        }));

        const params = {
            model,
            contents,
            config: {
                systemInstruction,
                temperature: modelParams.temperature ?? (isDeepAnalysis ? 0.5 : 0.7),
                topP: modelParams.topP ?? 0.95,
                ...(modelParams.topK && { topK: modelParams.topK }),
                ...(isWebAccessEnabled && { tools: [{ googleSearch: {} }] }),
            },
        };
        const result = await ai.models.generateContentStream(params);

        for await (const chunk of result) {
            res.write(`data: ${JSON.stringify(chunk)}\n\n`);
        }
    } catch (error) {
        console.error('Error in /api/chat:', error);
        res.write(`data: ${JSON.stringify({ error: true, message: error.message })}\n\n`);
    } finally {
        res.end();
    }
});

/**
 * Image generation endpoint.
 */
app.post('/api/image', async (req, res) => {
    try {
        const { prompt, aspectRatio, numberOfImages } = req.body;
        const response = await ai.models.generateImages({
            model: 'imagen-3.0-generate-002',
            prompt,
            config: { numberOfImages, outputMimeType: 'image/jpeg', aspectRatio },
        });

        if (response.generatedImages?.length > 0) {
            const urls = response.generatedImages.map(img => `data:image/jpeg;base64,${img.image.imageBytes}`);
            res.json({ images: urls });
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        sendError(res, "Failed to generate image. The model might have refused the prompt for safety reasons.");
    }
});

/**
 * All-purpose, non-streaming text generation endpoint
 */
async function generateText(req, res, prompt, config = {}) {
     try {
        const response = await ai.models.generateContent({ model, contents: prompt, ...config });
        return response.text;
    } catch (error) {
        sendError(res, `Failed to generate text: ${error.message}`);
        return null;
    }
}

app.post('/api/code-suggestion', async (req, res) => {
    const { code, language, action } = req.body;
    const prompt = `Action: ${action} the following ${language} code. IMPORTANT: Respond ONLY with the raw code, without any markdown formatting or explanation.\n\nCODE:\n${code}`;
    const suggestion = await generateText(req, res, prompt);
    if (suggestion) res.json({ suggestion });
});

app.post('/api/workspace-analysis', async (req, res) => {
    const { fileList } = req.body;
    const prompt = `Analyze this file structure and suggest 3 high-level improvements or next steps. File list: ${fileList.join(', ')}`;
    const config = {
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            suggestions: {
              type: Type.ARRAY,
              items: { type: Type.STRING },
            },
          },
        },
      }
    };
    const responseJson = await generateText(req, res, prompt, config);
    if (responseJson) res.send(responseJson);
});


app.post('/api/task-plan', async (req, res) => {
    const { goal } = req.body;
    const prompt = `Create a step-by-step plan to achieve this programming goal: "${goal}". The user has tools like createFile, updateFile.`;
    const config = {
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            plan: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  description: { type: Type.STRING },
                },
              },
            },
          },
        },
      }
    };
    const responseJson = await generateText(req, res, prompt, config);
    if (responseJson) res.send(responseJson);
});

app.post('/api/widget', async (req, res) => {
    const { prompt } = req.body;
    const fullPrompt = `Generate a single React JSX component as a string for this prompt: "${prompt}". Use TailwindCSS for styling. The component must be self-contained. Respond ONLY with the raw JSX, starting with a div or fragment.`;
    const jsx = await generateText(req, res, fullPrompt);
    if (jsx) res.json({ jsx: jsx.replace(/```jsx\n|```/g, '').trim() });
});

app.post('/api/image-prompt', async (req, res) => {
    const { modificationPrompt, image } = req.body;
    const contents = { parts: [
      { inlineData: { mimeType: image.mimeType, data: image.data } },
      { text: `Based on the attached image, create a new detailed, photorealistic image prompt that incorporates this modification: "${modificationPrompt}". The new prompt should describe the entire scene.` }
    ]};
    const prompt = await generateText(req, res, contents);
    if (prompt) res.json({ prompt });
});

app.post('/api/classify-intent', async (req, res) => {
    const { prompt } = req.body;
    const fullPrompt = `Is the user's primary intent "image_generation" or "chat"? Respond with ONLY one of those two options. User prompt: "${prompt}"`;
    const intent = await generateText(req, res, fullPrompt, { config: { temperature: 0 } });
    if (intent) res.json({ intent: intent.trim().toLowerCase().includes('image') ? 'image_generation' : 'chat' });
});


// Add a root route to confirm the API server is running
app.get('/', (req, res) => {
    res.setHeader('Content-Type', 'text/html');
    res.send(`
        <body style="font-family: sans-serif; background-color: #111827; color: #F9FAFB; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0;">
            <div style="text-align: center;">
                <h1 style="color: #8B5CF6; font-size: 2.5rem;">MentorX Backend</h1>
                <p style="font-size: 1.2rem;">API server is up and running.</p>
                <p style="color: #9CA3AF;">This is the backend service for the MentorX application. Please visit the frontend URL to use the app.</p>
            </div>
        </body>
    `);
});

// --- START SERVER ---
app.listen(port, () => {
    console.log(`MentorX server running at http://localhost:${port}`);
    console.log("-------------------------------------------------");
    console.log("IMPORTANT: Set the API_KEY environment variable.");
    console.log("For example: API_KEY='your_gemini_api_key' npm start");
    console.log("-------------------------------------------------");
});

// --- HELPER FUNCTIONS ---
const generateSystemInstruction = (persona, isWebAccessEnabled, isCostSaverMode, isDeepAnalysis, customInstruction) => {
  const custom = customInstruction ? `CRITICAL USER-DEFINED INSTRUCTION: You MUST follow this directive: "${customInstruction}"` : "";
  const web = isWebAccessEnabled ? "Web access is enabled. Use Google Search for current info and cite sources." : "Web access is disabled.";
  const brevity = isCostSaverMode ? "Priority: EXTREME BREVITY. Be as concise as possible." : "Provide comprehensive, natural responses.";
  const analysis = isDeepAnalysis ? "CRITICAL: DEEP ANALYSIS MODE. Provide expert-level, detailed responses." : brevity;
  return `${persona.system_prompt_segment}\n\n${custom}\n\nCore Directives:\n1. Formatting: Use markdown.\n2. Web Access: ${web}\n3. Response Style: ${analysis}`;
};