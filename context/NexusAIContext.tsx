import React, { createContext, useState, useCallback, ReactNode, useEffect, useMemo, useRef } from 'react';
import { EvolutionState, ChatMessage, SkillId, ChatSession, IMentorXContext, Source, EfficiencyStats, AppearanceSettings, Persona, Theme, WorkspaceState, CodeFile, ToolCall, ToolResponsePart, Task, TaskStep, AiWidget, User, Attachment, UiSettings, UserDataBundle } from '../types';
import { INITIAL_EVOLUTION_STATE, MENTORX_CORE_CACHE, MENTORX_PERSONAS, THEME_OPTIONS, MENTORX_MODES, SUPPORTED_LANGUAGES, COST_SAVER_SYSTEM_PROMPT_TOKEN_COUNT, ORIGINAL_SYSTEM_PROMPT_TOKEN_COUNT, resolvePersonaIcon } from '../constants';
import { streamMentorXResponse, generateMentorXImage, getAiCodeSuggestion, getWorkspaceAnalysis, generateTaskPlan, generateAiWidget, generatePromptForImageEditing, classifyPromptIntent, initializeAiClient, getAiInitializationError } from '../services/geminiService';
import { getUserDataBundle, saveUserDataBundle } from '../services/firestoreService';
import { GenerateContentResponse, Part } from '@google/genai';

declare const google: any;

export const MentorXContext = createContext<IMentorXContext | undefined>(undefined);

const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
const approxTokens = (text: string) => Math.ceil((text || '').length / 4);

const DEFAULT_APPEARANCE: AppearanceSettings = {
    activeThemeId: 'default',
    customThemes: [],
    backgroundImage: '',
    backgroundOpacity: 20,
    customCss: '/* Your custom CSS rules will be applied here */\n',
};

const DEFAULT_UI_SETTINGS: UiSettings = {
    isSidebarCollapsed: false,
    showRightSidebar: true,
    showSidebar: true,
    dashboardWidgetIds: [],
};

const getLanguageFromFileName = (fileName: string): string => {
    const extension = '.' + fileName.split('.').pop();
    const lang = SUPPORTED_LANGUAGES.find(l => l.extensions.includes(extension?.toLowerCase() || ''));
    return lang ? lang.value : 'plaintext';
};

const DEFAULT_SANDBOX_WORKSPACE_STATE: WorkspaceState = {
    files: [
        { id: generateId(), name: 'index.html', language: 'html', code: `<!DOCTYPE html>
<html>
<head>
  <title>Code Sandbox</title>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <h1>Hello, Sandbox!</h1>
  <p>You can edit this file or ask the AI to build something for you.</p>
  <script type="module" src="./main.js"></script>
</body>
</html>` },
        { id: generateId(), name: 'main.js', language: 'javascript', code: `// Welcome to your Code Sandbox!
console.log("Hello from main.js!");

const app = document.createElement('div');
app.textContent = 'This content was generated by JavaScript.';
document.body.appendChild(app);
` },
        { id: generateId(), name: 'style.css', language: 'css', code: `body {
  font-family: sans-serif;
  background-color: #f0f0f0;
  color: #333;
}` },
    ],
    activeFileId: null,
    output: 'Welcome to the Code Sandbox! Ask the AI to build something, or hit "Run" to see your code in action.',
    previewHtml: null,
};

const DEFAULT_GAMEDEV_WORKSPACE_STATE: WorkspaceState = {
    files: [
         { id: generateId(), name: 'index.html', language: 'html', code: `<!DOCTYPE html>
<html>
<head>
  <title>Game Preview</title>
  <style>
    body { margin: 0; background: #111; display: flex; align-items-center; justify-content: center; height: 100vh; color: white; font-family: monospace; }
    canvas { border: 1px solid #333; background-color: #000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="480" height="320"></canvas>
  <script type="module" src="./main.js"></script>
</body>
</html>` },
        { id: generateId(), name: 'main.js', language: 'javascript', code: `// Main game loop and setup
import Player from './player.js';
import { log } from './utils.js';

log('Game starting...');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const player = new Player('Hero', canvas.width / 2, canvas.height / 2);

let angle = 0;

function gameLoop() {
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update player position
    player.x = canvas.width / 2 + Math.sin(angle) * 100;
    player.y = canvas.height / 2 + Math.cos(angle) * 100;
    angle += 0.02;

    // Draw player
    player.draw(ctx);

    requestAnimationFrame(gameLoop);
}

log('Game setup complete. Starting loop...');
gameLoop();
` },
        { id: generateId(), name: 'player.js', language: 'javascript', code: `// Player class
import { log } from './utils.js';

export default class Player {
    constructor(name, x, y) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.size = 20;
        this.color = 'cyan';
        log(\`Player \${this.name} created.\`);
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}
` },
        { id: generateId(), name: 'utils.js', language: 'javascript', code: `// Utility functions

export function log(message) {
    console.log(\`[GAME] - \${message}\`);
}
` },
    ],
    activeFileId: null,
    output: 'Welcome to the Game Dev Console! Hit "Run" to see your game.',
    previewHtml: null,
};

const decodeJwt = (token: string): User | null => {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        
        const decoded = JSON.parse(jsonPayload);
        return {
            id: decoded.sub,
            name: decoded.name,
            email: decoded.email,
            picture: decoded.picture,
        };
    } catch (e) {
        console.error("Error decoding JWT", e);
        return null;
    }
};

const DEFAULT_STATS: EfficiencyStats = { apiCallsAvoided: 0, tokensSaved: 0 };

export const MentorXProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // State
  const [user, setUser] = useState<User | null>(null);
  const [isUserDataLoading, setIsUserDataLoading] = useState(true);
  
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [evolutionState, setEvolutionState] = useState<EvolutionState>(INITIAL_EVOLUTION_STATE);
  const [stats, setStats] = useState<EfficiencyStats>(DEFAULT_STATS);
  const [customPersonas, setCustomPersonas] = useState<Persona[]>([]);
  const [customInstruction, setCustomInstruction] = useState('');
  
  const [appearanceSettings, setAppearanceSettings] = useState<AppearanceSettings>(DEFAULT_APPEARANCE);
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(DEFAULT_UI_SETTINGS.isSidebarCollapsed);
  const [showRightSidebar, setShowRightSidebar] = useState(DEFAULT_UI_SETTINGS.showRightSidebar);
  const [showSidebar, setShowSidebar] = useState(DEFAULT_UI_SETTINGS.showSidebar);
  const [dashboardWidgetIds, setDashboardWidgetIds] = useState<string[]>(DEFAULT_UI_SETTINGS.dashboardWidgetIds);

  const [isLoading, setIsLoading] = useState(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isLowFidelityMode, setIsLowFidelityMode] = useState(false);
  const [isCostSaverMode, setIsCostSaverMode] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');
  const [isCommandPaletteOpen, setIsCommandPaletteOpen] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isFocusMode, setIsFocusMode] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [configError, setConfigError] = useState<string | null>(null);

  // Refs
  const stopGenerationRef = useRef(false);
  const initialLoadComplete = useRef(false);
  const saveTimeoutRef = useRef<number | null>(null);
  const recognitionRef = useRef<any>(null);

  // --- CONFIG & AUTH ---

  useEffect(() => {
    // This effect runs once on mount to initialize services and check configuration.
    initializeAiClient();
    setConfigError(getAiInitializationError());
  }, []);

  const resetStateToDefault = () => {
    setSessions([]);
    setActiveSessionId(null);
    setEvolutionState(INITIAL_EVOLUTION_STATE);
    setStats(DEFAULT_STATS);
    setCustomPersonas([]);
    setCustomInstruction('');
    setAppearanceSettings(DEFAULT_APPEARANCE);
    setIsSidebarCollapsed(DEFAULT_UI_SETTINGS.isSidebarCollapsed);
    setShowRightSidebar(DEFAULT_UI_SETTINGS.showRightSidebar);
    setShowSidebar(DEFAULT_UI_SETTINGS.showSidebar);
    setDashboardWidgetIds(DEFAULT_UI_SETTINGS.dashboardWidgetIds);
  }

  const loadUserData = useCallback(async (userData: User) => {
    setIsUserDataLoading(true);
    const cloudData = await getUserDataBundle(userData);

    if (cloudData) {
        setSessions(cloudData.sessions || []);
        setCustomPersonas(cloudData.customPersonas || []);
        setAppearanceSettings(cloudData.appearanceSettings || DEFAULT_APPEARANCE);
        setCustomInstruction(cloudData.customInstruction || '');
        setEvolutionState(cloudData.evolutionState || INITIAL_EVOLUTION_STATE);
        setStats(cloudData.stats || DEFAULT_STATS);
        
        const uiSettings = cloudData.uiSettings || DEFAULT_UI_SETTINGS;
        setIsSidebarCollapsed(uiSettings.isSidebarCollapsed);
        setShowRightSidebar(uiSettings.showRightSidebar);
        setShowSidebar(uiSettings.showSidebar);
        setDashboardWidgetIds(uiSettings.dashboardWidgetIds);
    } else {
        resetStateToDefault();
    }

    setActiveSessionId(null);
    setIsUserDataLoading(false);
    initialLoadComplete.current = true;
  }, []);

  const login = useCallback(async (credential: string) => {
    const userData = decodeJwt(credential);
    if (userData) {
      setUser(userData);
      localStorage.setItem('mentorx_user', JSON.stringify(userData));
      await loadUserData(userData);
    }
  }, [loadUserData]);

  const logout = useCallback(() => {
    if (typeof google !== 'undefined' && google.accounts?.id) {
        google.accounts.id.disableAutoSelect();
    }
    localStorage.removeItem('mentorx_user');
    setUser(null);
    resetStateToDefault();
  }, []);
  
  useEffect(() => {
    const savedUser = localStorage.getItem('mentorx_user');
    if (savedUser) {
        const userData = JSON.parse(savedUser);
        setUser(userData);
        loadUserData(userData);
    } else {
        setIsUserDataLoading(false);
        initialLoadComplete.current = true;
    }
  }, [loadUserData]);

  const saveData = useCallback(() => {
    if (!initialLoadComplete.current || !user || isUserDataLoading) return;

    setSaveStatus('saving');
    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

    saveTimeoutRef.current = window.setTimeout(async () => {
      const dataBundle: UserDataBundle = {
        sessions,
        customPersonas,
        appearanceSettings,
        customInstruction,
        uiSettings: {
          isSidebarCollapsed,
          showRightSidebar,
          showSidebar,
          dashboardWidgetIds,
        },
        evolutionState,
        stats,
      };
      try {
        await saveUserDataBundle(user, dataBundle);
        setSaveStatus('saved');
        setTimeout(() => setSaveStatus('idle'), 2000);
      } catch (error) {
        console.error("Failed to save data to cloud:", error);
        setSaveStatus('idle');
      }
    }, 1500);
  }, [
    user, isUserDataLoading, sessions, customPersonas, appearanceSettings, 
    customInstruction, isSidebarCollapsed, showRightSidebar, showSidebar, 
    dashboardWidgetIds, evolutionState, stats
  ]);

  useEffect(() => {
    if (user) {
      saveData();
    }
  }, [saveData, user]);


  // --- COMPUTED VALUES ---

  const activeSession = useMemo(() => sessions.find(s => s.id === activeSessionId), [sessions, activeSessionId]);
  
  const allPersonas = useMemo(() => [...MENTORX_PERSONAS, ...customPersonas], [customPersonas]);

  const activePersona = useMemo(() => {
      if (!activeSession) {
          const defaultPersona = MENTORX_PERSONAS[0];
          return { ...defaultPersona, icon: resolvePersonaIcon(defaultPersona.icon) };
      }
      const persona = allPersonas.find(p => p.id === activeSession.activePersonaId) || MENTORX_PERSONAS[0];
      return { ...persona, icon: resolvePersonaIcon(persona.icon) };
  }, [activeSession, allPersonas]);
  
  const theme = useMemo(() => {
      const allThemes = [...THEME_OPTIONS, ...appearanceSettings.customThemes];
      return allThemes.find(t => t.id === appearanceSettings.activeThemeId) || THEME_OPTIONS[0];
  }, [appearanceSettings.activeThemeId, appearanceSettings.customThemes]);

  const isPremiumUser = !!user;

  // --- SESSION/CHAT MANAGEMENT ---
  
  const startNewChat = useCallback((personaId: string = 'default') => {
    const persona = allPersonas.find(p => p.id === personaId) || MENTORX_PERSONAS[0];
    
    const newSession: ChatSession = {
      id: generateId(),
      title: persona.name,
      messages: [],
      modeId: 'mentor',
      isWebAccessEnabled: false,
      isDeepAnalysis: false,
      createdAt: new Date(),
      totalTokens: 0,
      activePersonaId: persona.id,
      temperature: 0.7,
      topP: 0.95,
      topK: undefined,
      widgets: [],
      activeWidgetId: null,
    };

    if (personaId === 'gamedev' || personaId === 'sandbox') {
        const defaultState = personaId === 'gamedev' ? DEFAULT_GAMEDEV_WORKSPACE_STATE : DEFAULT_SANDBOX_WORKSPACE_STATE;
        newSession.workspaceState = {
            ...defaultState,
            files: defaultState.files.map(f => ({ ...f, id: generateId() })),
            activeFileId: null
        };
    }
    
    if (personaId === 'widget_factory') {
        newSession.title = "New Widget Session";
    }

    setSessions(prev => [newSession, ...prev]);
    setActiveSessionId(newSession.id);
  }, [allPersonas]);
  
  const deleteChat = useCallback((sessionId: string) => {
    setSessions(prev => prev.filter(s => s.id !== sessionId));
    if (activeSessionId === sessionId) {
      setActiveSessionId(null);
    }
  }, [activeSessionId]);

  const renameChat = useCallback((sessionId: string, newTitle: string) => {
    setSessions(prev => prev.map(s => s.id === sessionId ? { ...s, title: newTitle } : s));
  }, []);

  const exportChat = useCallback((sessionId: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session) return;
    const content = session.messages.map(m => `**${m.role.toUpperCase()}**: ${m.text}`).join('\n\n');
    const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${session.title.replace(/ /g, '_')}.md`;
    link.click();
  }, [sessions]);

  // --- AI INTERACTION ---
  
  const stopGeneration = useCallback(() => {
      stopGenerationRef.current = true;
  }, []);

  const updateSession = useCallback((sessionId: string, updates: Partial<ChatSession> | ((session: ChatSession) => Partial<ChatSession>)) => {
    setSessions(prev => prev.map(s => {
        if (s.id === sessionId) {
            const changes = typeof updates === 'function' ? updates(s) : updates;
            return { ...s, ...changes };
        }
        return s;
    }));
  }, []);

  const _sendMessageInternal = useCallback(async (
    sessionId: string, 
    history: ChatMessage[],
    attachment: Attachment | null = null,
    boosted: boolean = false,
  ) => {
      const session = sessions.find(s => s.id === sessionId);
      const persona = allPersonas.find(p => p.id === session?.activePersonaId) || MENTORX_PERSONAS[0];
      if (!session || !persona) return;
      
      setIsLoading(true);
      stopGenerationRef.current = false;
      
      let filePart: Part | null = attachment ? { inlineData: { data: attachment.data, mimeType: attachment.type } } : null;

      const assistantMessageId = generateId();
      const assistantMessage: ChatMessage = { id: assistantMessageId, role: 'assistant', text: '', timestamp: new Date(), toolCalls: [], };

      updateSession(sessionId, { messages: [...history, assistantMessage] });
      
      const processStream = async (streamHistory: ChatMessage[]) => {
          try {
              const stream = await streamMentorXResponse(
                streamHistory, 
                persona, 
                session.isWebAccessEnabled, 
                isCostSaverMode, 
                session.isDeepAnalysis || boosted,
                customInstruction, 
                streamHistory.length === history.length + 1 ? filePart : null,
                { temperature: session.temperature, topP: session.topP, topK: session.topK }
              );

              let textResponse = '';
              let toolCalls: ToolCall[] = [];
              let lastChunk: GenerateContentResponse | undefined;

              for await (const chunk of stream) {
                  if (stopGenerationRef.current) break;
                  
                  if (chunk.text) {
                      textResponse += chunk.text;
                      updateSession(sessionId, s => ({
                          messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: textResponse } : m)
                      }));
                  }
                  
                  const functionCallsFromChunk = chunk.functionCalls;
                  if (functionCallsFromChunk) {
                      const newToolCalls: ToolCall[] = functionCallsFromChunk.map((part, index) => ({
                          id: `${part.name}_${index}_${Date.now()}`,
                          type: 'function' as const,
                          function: { name: part.name, arguments: part.args }
                      }));
                      toolCalls.push(...newToolCalls);
                      updateSession(sessionId, s => ({
                          messages: s.messages.map(m => {
                              if (m.id === assistantMessageId) {
                                  return { ...m, toolCalls: [...(m.toolCalls || []), ...newToolCalls] };
                              }
                              return m;
                          })
                      }));
                  }
                  lastChunk = chunk;
              }

              const finalAssistantMsg: Partial<ChatMessage> = { text: textResponse, toolCalls: toolCalls.length > 0 ? toolCalls : undefined };
              if (lastChunk?.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                finalAssistantMsg.sources = lastChunk.candidates[0].groundingMetadata.groundingChunks
                    .map((c: any) => c.web).filter((c: any) => c?.uri && c?.title);
              }
              const finalTokens = approxTokens(textResponse);
              finalAssistantMsg.tokens = finalTokens;
              updateSession(sessionId, s => ({ 
                totalTokens: (s.totalTokens || 0) + finalTokens,
                messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, ...finalAssistantMsg } : m)
              }));

              if (toolCalls.length > 0 && !stopGenerationRef.current) {
                  const toolResponses = await executeToolCalls(toolCalls, sessionId);
                  const toolMessage: ChatMessage = {
                      id: generateId(), role: 'tool', text: '', timestamp: new Date(), toolResponses: toolResponses,
                  };
                  const newHistory = [...streamHistory, { ...assistantMessage, ...finalAssistantMsg }, toolMessage];
                  updateSession(sessionId, { messages: newHistory });
                  await processStream(newHistory);
              }
          } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
              updateSession(sessionId, s => ({
                  messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: `Error: ${errorMessage}` } : m)
              }));
          }
      };

      await processStream([...history, assistantMessage]);

      setIsLoading(false);
  }, [sessions, allPersonas, isCostSaverMode, customInstruction, updateSession]);

  const sendMessage = useCallback(async (prompt: string, attachment: Attachment | null = null, options: { aspectRatio?: string, numberOfImages?: number } = {}, boosted: boolean = false) => {
      if (!activeSessionId) return;

      if(prompt.toLowerCase().startsWith('/execute ')){
          const goal = prompt.substring(9).trim();
          executeTask(activeSessionId, goal);
          return;
      }
      if(prompt.toLowerCase().trim() === '/analyze'){
        performAiCodeAction(activeSessionId, 'analyze');
        return;
      }

      const session = sessions.find(s => s.id === activeSessionId);
      if (!session) return;
      
      if (attachment && prompt && !options.aspectRatio && attachment.type.startsWith('image/')) {
        setIsLoading(true);
        const userMessage: ChatMessage = {
            id: generateId(), role: 'user', text: prompt, timestamp: new Date(),
            attachment: attachment,
        };
        const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: "Re-imagining your image...", timestamp: new Date() };

        updateSession(activeSessionId, s => ({ messages: [...s.messages, userMessage, assistantMessage] }));

        try {
            const newImagePrompt = await generatePromptForImageEditing(prompt, { data: attachment.data, mimeType: attachment.type });
            const imageUrls = await generateMentorXImage(newImagePrompt);
            const [header, data] = imageUrls[0].split(',');
            const mimeType = header.match(/:(.*?);/)?.[1] || 'image/jpeg';
            const newAttachment: Attachment = { name: "edited-image.jpg", type: mimeType, data: data, size: data.length };
            
            updateSession(activeSessionId, s => ({
                messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Here is the edited image based on your prompt: "${prompt}"`, attachment: newAttachment } : m)
            }));
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during image editing.";
            updateSession(activeSessionId, s => ({
                messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Error: ${errorMessage}` } : m)
            }));
        } finally {
            setIsLoading(false);
        }
        return;
    }

      if (options.aspectRatio) {
          setIsLoading(true);
          const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date() };
          const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: "Generating your image(s)...", timestamp: new Date() };
          updateSession(activeSessionId, s => ({ messages: [...s.messages, userMessage, assistantMessage] }));
          try {
              const imageUrls = await generateMentorXImage(prompt, options.aspectRatio, options.numberOfImages);
              const [header, data] = imageUrls[0].split(',');
              const mimeType = header.match(/:(.*?);/)?.[1] || 'image/jpeg';
              const imgAttachment: Attachment = { name: "generated-image.jpg", type: mimeType, data: data, size: data.length };
              updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Here are the images you requested for "${prompt}"`, attachment: imgAttachment } : m) }));
          } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during image generation.";
              updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Error: ${errorMessage}` } : m) }));
          } finally {
              setIsLoading(false);
          }
          return;
      }
      
      const specialPersonas = ['gamedev', 'sandbox', 'widget_factory'];
      if (!attachment && prompt && !specialPersonas.includes(session.activePersonaId || '')) {
          const intent = await classifyPromptIntent(prompt);
          if (intent === 'image_generation') {
              setIsLoading(true);
              const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date() };
              const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: "Generating your image...", timestamp: new Date() };
              updateSession(activeSessionId, s => ({ messages: [...s.messages, userMessage, assistantMessage] }));
              try {
                  const imageUrls = await generateMentorXImage(prompt, '1:1', 1);
                  const [header, data] = imageUrls[0].split(',');
                  const mimeType = header.match(/:(.*?);/)?.[1] || 'image/jpeg';
                  const imgAttachment: Attachment = { name: "generated-image.jpg", type: mimeType, data: data, size: data.length };
                  updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Here is the image you requested:`, attachment: imgAttachment } : m) }));
              } catch (error) {
                  const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during image generation.";
                  updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Error: ${errorMessage}` } : m) }));
              } finally {
                  setIsLoading(false);
              }
              return;
          }
      }

      const cacheKey = prompt.toLowerCase().trim();
      if (MENTORX_CORE_CACHE.has(cacheKey) && !session.isWebAccessEnabled) {
          const cachedResponse = MENTORX_CORE_CACHE.get(cacheKey)!;
          const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date() };
          const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: cachedResponse, timestamp: new Date(), isCached: true };
          updateSession(activeSessionId, { messages: [...session.messages, userMessage, assistantMessage] });
          setStats(s => ({ ...s, apiCallsAvoided: s.apiCallsAvoided + 1, tokensSaved: s.tokensSaved + approxTokens(cachedResponse) }));
          return;
      }
      
      const userMessage: ChatMessage = {
          id: generateId(), role: 'user', text: prompt, timestamp: new Date(),
          attachment: attachment || undefined,
      };

      const newHistory = [...session.messages, userMessage];
      updateSession(activeSessionId, { messages: newHistory });
      await _sendMessageInternal(activeSessionId, newHistory, attachment, boosted);

  }, [activeSessionId, sessions, _sendMessageInternal, updateSession]);

  const editMessage = useCallback(async (sessionId: string, messageId: string, newText: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session) return;
    
    const messageIndex = session.messages.findIndex(m => m.id === messageId);
    if (messageIndex === -1 || session.messages[messageIndex].role !== 'user') return;

    const historyUpToEdit = session.messages.slice(0, messageIndex);
    const editedMessage: ChatMessage = { ...session.messages[messageIndex], text: newText };
    const newHistory = [...historyUpToEdit, editedMessage];

    updateSession(sessionId, { messages: newHistory, activeTask: null });
    await _sendMessageInternal(sessionId, newHistory, editedMessage.attachment || null);
  }, [sessions, _sendMessageInternal, updateSession]);

  const regenerateLastResponse = useCallback(async (sessionId: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session || session.messages.length === 0) return;

    let lastUserMessageIndex = -1;
    for (let i = session.messages.length - 1; i >= 0; i--) {
        if (session.messages[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    if (lastUserMessageIndex === -1) return;

    const newHistory = session.messages.slice(0, lastUserMessageIndex + 1);
    const lastUserMessage = newHistory[newHistory.length - 1];
    
    updateSession(sessionId, { messages: newHistory, activeTask: null });
    await _sendMessageInternal(sessionId, newHistory, lastUserMessage.attachment || null);
  }, [sessions, _sendMessageInternal, updateSession]);

  // --- WORKSPACE & CODECANVAS ---
  
  const executeToolCalls = async (toolCalls: ToolCall[], sessionId: string): Promise<ToolResponsePart[]> => {
    const responses: ToolResponsePart[] = [];
    const sessionRef = { ...sessions.find(s => s.id === sessionId)! };
    
    for (const call of toolCalls) {
        let response: Record<string, any> = { success: false, message: 'Tool not found' };
        try {
            switch (call.function.name) {
                // WORKSPACE TOOLS
                case 'createFile':
                    if (sessionRef.workspaceState) {
                        const newFile: CodeFile = { id: generateId(), name: call.function.arguments.fileName, code: call.function.arguments.code || '', language: getLanguageFromFileName(call.function.arguments.fileName) };
                        sessionRef.workspaceState.files.push(newFile);
                        response = { success: true, message: `File ${call.function.arguments.fileName} created.` };
                    }
                    break;
                case 'updateFile':
                    if (sessionRef.workspaceState) {
                        const fileToUpdate = sessionRef.workspaceState.files.find(f => f.name === call.function.arguments.fileName);
                        if (fileToUpdate) {
                            fileToUpdate.code = call.function.arguments.code;
                            response = { success: true, message: `File ${call.function.arguments.fileName} updated.` };
                        } else {
                            const newFileOnUpdate: CodeFile = { id: generateId(), name: call.function.arguments.fileName, code: call.function.arguments.code || '', language: getLanguageFromFileName(call.function.arguments.fileName) };
                            sessionRef.workspaceState.files.push(newFileOnUpdate);
                            response = { success: true, message: `File ${call.function.arguments.fileName} was not found, so it was created instead.` };
                        }
                    }
                    break;
                case 'listFiles':
                    if (sessionRef.workspaceState) {
                        response = { files: sessionRef.workspaceState.files.map(f => f.name) };
                    }
                    break;
                case 'generateTestFile':
                     if (sessionRef.workspaceState) {
                         const sourceFile = sessionRef.workspaceState.files.find(f => f.name === call.function.arguments.fileName);
                         if (sourceFile) {
                            const testCode = await getAiCodeSuggestion(sourceFile.code, sourceFile.language, 'test', call.function.arguments.framework);
                            const parts = sourceFile.name.split('.');
                            const testFileName = `${parts[0]}.test.${parts[1]}`;
                            const newTestFile: CodeFile = { id: generateId(), name: testFileName, code: testCode, language: getLanguageFromFileName(testFileName) };
                            sessionRef.workspaceState.files.push(newTestFile);
                            response = { success: true, message: `Test file ${testFileName} created.` };
                         } else {
                            response = { success: false, message: `Source file not found: ${call.function.arguments.fileName}` };
                         }
                     }
                    break;
                // WIDGET TOOLS
                case 'createWidget':
                    const jsx = await generateAiWidget(call.function.arguments.prompt);
                    const newWidget: AiWidget = { id: generateId(), prompt: call.function.arguments.prompt, jsx, lastUpdatedAt: new Date() };
                    sessionRef.widgets = [...(sessionRef.widgets || []), newWidget];
                    sessionRef.activeWidgetId = newWidget.id;
                    response = { success: true, message: `Widget created successfully.` };
                    break;
                case 'updateWidget':
                    const { widgetId, newPrompt } = call.function.arguments;
                    const newJsx = await generateAiWidget(newPrompt);
                    sessionRef.widgets = (sessionRef.widgets || []).map(w =>
                        w.id === widgetId ? { ...w, jsx: newJsx, prompt: newPrompt, lastUpdatedAt: new Date() } : w
                    );
                    response = { success: true, message: `Widget ${widgetId} updated.` };
                    break;
            }
        } catch(e) {
            response = { success: false, message: e instanceof Error ? e.message : 'Unknown error' };
        }
        responses.push({ toolCallId: call.id, functionName: call.function.name, response });
    }
    updateSession(sessionId, { 
        workspaceState: sessionRef.workspaceState, 
        widgets: sessionRef.widgets,
        activeWidgetId: sessionRef.activeWidgetId,
    });
    return responses;
  };
  
  const updateWorkspaceState = (sessionId: string, updates: Partial<WorkspaceState>) => {
      updateSession(sessionId, s => ({ workspaceState: { ...s.workspaceState!, ...updates }}));
  };
  
  const addCodeFile = useCallback((sessionId: string, fileName: string, code: string = '') => {
      const newFile: CodeFile = { id: generateId(), name: fileName, code, language: getLanguageFromFileName(fileName) };
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          return { workspaceState: { ...ws, files: [...ws.files, newFile], activeFileId: newFile.id }};
      });
  }, [updateSession]);
  
  const deleteCodeFile = useCallback((sessionId: string, fileId: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.filter(f => f.id !== fileId);
          const newActiveFileId = ws.activeFileId === fileId ? (newFiles[0]?.id || null) : ws.activeFileId;
          return { workspaceState: { ...ws, files: newFiles, activeFileId: newActiveFileId } };
      });
  }, [updateSession]);
  
  const renameCodeFile = useCallback((sessionId: string, fileId: string, newName: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.map(f => f.id === fileId ? { ...f, name: newName, language: getLanguageFromFileName(newName) } : f);
          return { workspaceState: { ...ws, files: newFiles }};
      });
  }, [updateSession]);
  
  const setActiveCodeFile = useCallback((sessionId: string, fileId: string | null) => {
      updateWorkspaceState(sessionId, { activeFileId: fileId });
  }, []);
  
  const updateCodeFile = useCallback((sessionId: string, fileId: string, newCode: string, newLanguage?: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.map(f => f.id === fileId ? { ...f, code: newCode, language: newLanguage || f.language } : f);
          return { workspaceState: { ...ws, files: newFiles }};
      });
  }, [updateSession]);

  const runCode = useCallback(async (sessionId: string) => {
      const session = sessions.find(s => s.id === sessionId);
      if (!session?.workspaceState) return;

      updateWorkspaceState(sessionId, { output: '> Running project...\n' });

      const { files } = session.workspaceState;
      const htmlFile = files.find(f => f.name.endsWith('.html'));
      if (!htmlFile) {
          updateWorkspaceState(sessionId, { output: (session.workspaceState.output || '') + '> Error: No index.html file found.\n' });
          return;
      }

      let doc = new DOMParser().parseFromString(htmlFile.code, 'text/html');
      const blobUrls = new Map<string, string>();
      const importMap: { imports: Record<string, string> } = { imports: {} };

      // Process CSS
      doc.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
          const htmlLink = link as HTMLLinkElement;
          const href = htmlLink.getAttribute('href')!;
          const cssFile = files.find(f => `./${f.name}` === href);
          if (cssFile) {
              const blob = new Blob([cssFile.code], { type: 'text/css' });
              const url = URL.createObjectURL(blob);
              htmlLink.href = url;
              blobUrls.set(url, '');
          }
      });
      
      const loggerScript = `
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        console.log = (...args) => { window.parent.postMessage({ type: 'log', message: args.join(' ') }, '*'); originalLog(...args); };
        console.warn = (...args) => { window.parent.postMessage({ type: 'warn', message: args.join(' ') }, '*'); originalWarn(...args); };
        console.error = (...args) => { window.parent.postMessage({ type: 'error', message: args.join(' ') }, '*'); originalError(...args); };
        window.addEventListener('error', event => { console.error(event.message); });
      `;
      const loggerScriptEl = doc.createElement('script');
      loggerScriptEl.textContent = loggerScript;
      doc.head.insertBefore(loggerScriptEl, doc.head.firstChild);

      // Process JS
      for (const file of files.filter(f => f.language === 'javascript')) {
          const blob = new Blob([file.code], { type: 'application/javascript' });
          const url = URL.createObjectURL(blob);
          blobUrls.set(url, '');
          importMap.imports[`./${file.name}`] = url;
          importMap.imports[`./${file.name.replace('.js', '')}`] = url; // for module imports without extension
      }
      
      const importMapScript = doc.createElement('script');
      importMapScript.type = 'importmap';
      importMapScript.textContent = JSON.stringify(importMap);
      doc.head.appendChild(importMapScript);
      
      doc.querySelectorAll('script[src]').forEach(script => {
          const htmlScript = script as HTMLScriptElement;
          const src = htmlScript.getAttribute('src')!;
          if (importMap.imports[src]) {
              htmlScript.src = importMap.imports[src];
          }
      });

      const finalHtml = new XMLSerializer().serializeToString(doc);
      updateWorkspaceState(sessionId, { previewHtml: finalHtml, output: (session.workspaceState.output || '') + '> Build successful. Preview is ready.\n' });
      // Clean up blobs later
  }, [sessions, updateWorkspaceState]);
  
  const appendOutput = useCallback((sessionId: string, message: string) => {
      updateWorkspaceState(sessionId, { output: (activeSession?.workspaceState?.output || '') + message + '\n' });
  }, [activeSession, updateWorkspaceState]);

  const performAiCodeAction = useCallback(async (sessionId: string, action: 'refactor' | 'debug' | 'document' | 'explain' | 'test' | 'analyze') => {
      const session = sessions.find(s => s.id === sessionId);
      if (!session?.workspaceState) return;

      if(action === 'analyze') {
          setIsLoading(true);
          appendOutput(sessionId, `> AI is analyzing the workspace...`);
          try {
              const fileList = session.workspaceState.files.map(f => f.name);
              const suggestions = await getWorkspaceAnalysis(fileList);
              const assistantMessage: ChatMessage = {
                  id: generateId(),
                  role: 'assistant',
                  text: 'I have analyzed your workspace and here are my suggestions:',
                  timestamp: new Date(),
                  suggestedActions: suggestions,
              };
              updateSession(sessionId, s => ({ messages: [...s.messages, assistantMessage] }));
          } catch(error) {
              const message = error instanceof Error ? error.message : "An unknown error occurred.";
              appendOutput(sessionId, `> AI analysis failed: ${message}`);
          } finally {
              setIsLoading(false);
          }
          return;
      }
      
      if (!session.workspaceState.activeFileId) return;
      const file = session.workspaceState.files.find(f => f.id === session.workspaceState!.activeFileId);
      if (!file) return;

      setIsLoading(true);
      appendOutput(sessionId, `> AI is performing '${action}' on ${file.name}...`);
      try {
          const suggestion = await getAiCodeSuggestion(file.code, file.language, action);
          if (action === 'test') {
            const parts = file.name.split('.');
            const ext = parts.pop();
            const baseName = parts.join('.');
            const testFileName = `${baseName}.test.${ext}`;
            addCodeFile(sessionId, testFileName, suggestion);
            appendOutput(sessionId, `> AI action complete. New test file created: ${testFileName}`);
          } else {
            updateCodeFile(sessionId, file.id, suggestion, file.language);
            appendOutput(sessionId, `> AI action '${action}' on ${file.name} complete.`);
          }
      } catch (error) {
          const message = error instanceof Error ? error.message : "An unknown error occurred.";
          appendOutput(sessionId, `> AI action failed: ${message}`);
      } finally {
          setIsLoading(false);
      }
  }, [sessions, addCodeFile, updateCodeFile, appendOutput]);

  const executeTask = useCallback(async (sessionId: string, goal: string) => {
    setIsLoading(true);
    const userMessage: ChatMessage = { id: generateId(), role: 'user', text: `/execute ${goal}`, timestamp: new Date() };
    updateSession(sessionId, s => ({ messages: [...s.messages, userMessage] }));

    const task: Task = { id: generateId(), goal, plan: [], status: 'planning' };
    updateSession(sessionId, { activeTask: task });

    try {
        const planSteps = await generateTaskPlan(goal);
        task.plan = planSteps.map(step => ({ ...step, id: generateId(), status: 'pending' }));
        task.status = 'in-progress';
        updateSession(sessionId, { activeTask: { ...task } });

        for (let i = 0; i < task.plan.length; i++) {
            const step = task.plan[i];
            step.status = 'in-progress';
            updateSession(sessionId, { activeTask: { ...task } });
            
            const toolCall: ToolCall = { ...step.toolCall!, id: generateId() };
            const toolResponses = await executeToolCalls([toolCall], sessionId);
            const toolResponse = toolResponses[0];

            if (toolResponse.response.success) {
                step.status = 'completed';
            } else {
                step.status = 'failed';
                task.status = 'failed';
                task.error = toolResponse.response.message;
                break; 
            }
             updateSession(sessionId, { activeTask: { ...task } });
        }

        if (task.status !== 'failed') {
            task.status = 'completed';
        }

    } catch (error) {
        task.status = 'failed';
        task.error = error instanceof Error ? error.message : "Unknown error during planning.";
    }
    
    updateSession(sessionId, s => ({ ...s, activeTask: { ...s.activeTask!, ...task } }));
    setIsLoading(false);

  }, [updateSession, executeToolCalls]);


  const uploadWorkspace = useCallback(async (sessionId: string) => {
      alert("Workspace upload from a local folder is a conceptual feature for this demo.");
  }, []);

  const resetWorkspace = useCallback((sessionId: string) => {
      if (!window.confirm("Are you sure you want to reset the workspace? All changes will be lost.")) return;
      const session = sessions.find(s => s.id === sessionId);
      if (!session?.activePersonaId) return;
      
      const defaultState = session.activePersonaId === 'gamedev' ? DEFAULT_GAMEDEV_WORKSPACE_STATE : DEFAULT_SANDBOX_WORKSPACE_STATE;
      updateWorkspaceState(sessionId, {
        ...defaultState,
        files: defaultState.files.map(f => ({ ...f, id: generateId() })),
      });
  }, [sessions, updateWorkspaceState]);

  // WIDGETS
  const generateAndAddWidget = useCallback(async (sessionId: string, prompt: string) => {
      const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date() };
      const session = sessions.find(s => s.id === sessionId);
      if (!session) return;

      const newHistory = [...session.messages, userMessage];
      updateSession(sessionId, { messages: newHistory });
      await _sendMessageInternal(sessionId, newHistory, null);
  }, [sessions, updateSession, _sendMessageInternal]);

  const setActiveWidgetId = useCallback((sessionId: string, widgetId: string | null) => {
    updateSession(sessionId, { activeWidgetId: widgetId });
  }, [updateSession]);

  const deleteWidget = useCallback((sessionId: string, widgetId: string) => {
      updateSession(sessionId, s => ({
          widgets: (s.widgets || []).filter(w => w.id !== widgetId),
          activeWidgetId: s.activeWidgetId === widgetId ? null : s.activeWidgetId,
      }));
  }, [updateSession]);

  const clearWidgets = useCallback((sessionId: string) => {
    updateSession(sessionId, { widgets: [], activeWidgetId: null });
  }, [updateSession]);

  const addWidgetToDashboard = useCallback((widgetId: string) => {
    setDashboardWidgetIds(prev => [...new Set([...prev, widgetId])]);
  }, []);

  const removeWidgetFromDashboard = useCallback((widgetId: string) => {
      setDashboardWidgetIds(prev => prev.filter(id => id !== widgetId));
  }, []);


  // --- SETTINGS & CUSTOMIZATION ---
  
  const setSessionPersona = useCallback((sessionId: string, personaId: string) => updateSession(sessionId, { activePersonaId: personaId }), [updateSession]);
  const setSessionModelParams = useCallback((sessionId: string, params: { temperature?: number, topP?: number, topK?: number }) => updateSession(sessionId, params), [updateSession]);
  const toggleSessionWebAccess = useCallback((sessionId: string) => updateSession(sessionId, s => ({ isWebAccessEnabled: !s.isWebAccessEnabled })), [updateSession]);
  const toggleSessionDeepAnalysis = useCallback((sessionId: string) => updateSession(sessionId, s => ({ isDeepAnalysis: !s.isDeepAnalysis })), [updateSession]);
  const toggleLowFidelityMode = useCallback(() => setIsLowFidelityMode(prev => !prev), []);
  const toggleCostSaverMode = useCallback(() => setIsCostSaverMode(prev => !prev), []);
  const handleSetAppearanceSettings = useCallback((settings: Partial<AppearanceSettings>) => {
    setAppearanceSettings(prev => ({ ...prev, ...settings }));
  }, []);

  const addCustomPersona = useCallback((personaData: Omit<Persona, 'id' | 'isCustom' | 'isPro' | 'icon'> & {icon: string}) => {
      const newPersona: Persona = {
          ...personaData,
          id: `custom_${generateId()}`,
          isCustom: true,
          isPro: false, // Custom personas are not pro-locked
      };
      setCustomPersonas(prev => [...prev, newPersona]);
  }, []);
  
  const updateCustomPersona = useCallback((personaToUpdate: Persona) => {
      setCustomPersonas(prev => prev.map(p => p.id === personaToUpdate.id ? personaToUpdate : p));
  }, []);

  const deleteCustomPersona = useCallback((personaId: string) => {
      setCustomPersonas(prev => prev.filter(p => p.id !== personaId));
      setSessions(prev => prev.map(s => s.activePersonaId === personaId ? { ...s, activePersonaId: 'default' } : s));
  }, []);

  const addCustomTheme = useCallback((themeData: Omit<Theme, 'id' | 'isCustom' | 'isPro'>) => {
      const newTheme: Theme = { ...themeData, id: `custom_${generateId()}`, isCustom: true, isPro: false };
      setAppearanceSettings(prev => ({ ...prev, customThemes: [...prev.customThemes, newTheme], activeThemeId: newTheme.id }));
  }, []);

  const updateCustomTheme = useCallback((themeToUpdate: Theme) => {
      setAppearanceSettings(prev => ({ ...prev, customThemes: prev.customThemes.map(t => t.id === themeToUpdate.id ? themeToUpdate : t) }));
  }, []);

  const deleteCustomTheme = useCallback((themeId: string) => {
      setAppearanceSettings(prev => ({ ...prev, customThemes: prev.customThemes.filter(t => t.id !== themeId), activeThemeId: prev.activeThemeId === themeId ? 'default' : prev.activeThemeId }));
  }, []);

    // --- VOICE INPUT ---
    const startRecording = useCallback(() => {
        const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("Speech recognition is not supported in this browser.");
            return;
        }
        if (recognitionRef.current) {
            recognitionRef.current.stop();
        }
        
        recognitionRef.current = new SpeechRecognition();
        recognitionRef.current.continuous = false;
        recognitionRef.current.interimResults = false;
        recognitionRef.current.lang = 'en-US';
        
        recognitionRef.current.onstart = () => setIsRecording(true);
        recognitionRef.current.onend = () => setIsRecording(false);
        recognitionRef.current.onerror = (event: any) => {
            console.error("Speech recognition error:", event.error);
            setIsRecording(false);
        };
        
        recognitionRef.current.start();
    }, []);

    const stopRecording = useCallback((): Promise<string | undefined> => {
        return new Promise((resolve) => {
            if (recognitionRef.current) {
                recognitionRef.current.onresult = (event: any) => {
                    const transcript = event.results[0][0].transcript;
                    resolve(transcript);
                };
                recognitionRef.current.stop();
            } else {
                resolve(undefined);
            }
        });
    }, []);

  const value: IMentorXContext = useMemo(() => ({
      sessions, activeSessionId, activeSession, evolutionState, isLoading, isLowFidelityMode, isCostSaverMode, stats, isPremiumUser, searchQuery, customInstruction, isSidebarOpen, isSidebarCollapsed, saveStatus, appearanceSettings, theme, activePersona, customPersonas, showRightSidebar, showSidebar, isCommandPaletteOpen, isSettingsOpen, isFocusMode, isRecording, dashboardWidgetIds, user, isUserDataLoading, configError, login, logout, addWidgetToDashboard, removeWidgetFromDashboard,
      setSearchQuery, setCustomInstruction, setIsSidebarOpen, setIsSidebarCollapsed, setAppearanceSettings: handleSetAppearanceSettings, setShowRightSidebar, setShowSidebar, setIsCommandPaletteOpen, setIsSettingsOpen, setIsFocusMode,
      startNewChat, deleteChat, renameChat, setActiveSessionId, sendMessage, editMessage, regenerateLastResponse, stopGeneration, exportChat,
      toggleSessionWebAccess, toggleSessionDeepAnalysis, toggleLowFidelityMode, toggleCostSaverMode,
      setSessionPersona, setSessionModelParams,
      addCodeFile, deleteCodeFile, renameCodeFile, setActiveCodeFile, updateCodeFile, runCode, appendOutput, performAiCodeAction, uploadWorkspace, resetWorkspace, executeTask,
      // Widget methods
      clearWidgets, deleteWidget, generateAndAddWidget, setActiveWidgetId,
      addCustomPersona, updateCustomPersona, deleteCustomPersona,
      addCustomTheme, updateCustomTheme, deleteCustomTheme,
      startRecording, stopRecording,
  }), [
      sessions, activeSessionId, activeSession, evolutionState, isLoading, isLowFidelityMode, isCostSaverMode, stats, isPremiumUser, searchQuery, customInstruction, isSidebarOpen, isSidebarCollapsed, saveStatus, appearanceSettings, theme, activePersona, customPersonas, showRightSidebar, showSidebar, isCommandPaletteOpen, isSettingsOpen, isFocusMode, isRecording, dashboardWidgetIds, user, isUserDataLoading, configError, addWidgetToDashboard, removeWidgetFromDashboard,
      setSearchQuery, setCustomInstruction, setIsSidebarOpen, setIsSidebarCollapsed, handleSetAppearanceSettings, setShowRightSidebar, setShowSidebar, setActiveSessionId, setIsCommandPaletteOpen, setIsSettingsOpen, setIsFocusMode,
      startNewChat, deleteChat, renameChat, sendMessage, editMessage, regenerateLastResponse, stopGeneration, exportChat,
      toggleSessionWebAccess, toggleSessionDeepAnalysis, toggleLowFidelityMode, toggleCostSaverMode,
      setSessionPersona, setSessionModelParams, login, logout,
      addCodeFile, deleteCodeFile, renameCodeFile, setActiveCodeFile, updateCodeFile, runCode, appendOutput, performAiCodeAction, uploadWorkspace, resetWorkspace, executeTask,
      clearWidgets, deleteWidget, generateAndAddWidget, setActiveWidgetId,
      addCustomPersona, updateCustomPersona, deleteCustomPersona,
      addCustomTheme, updateCustomTheme, deleteCustomTheme,
      startRecording, stopRecording,
  ]);

  return (
    <MentorXContext.Provider value={value}>
      {children}
    </MentorXContext.Provider>
  );
};