import React, { createContext, useState, useCallback, ReactNode, useEffect, useMemo, useRef } from 'react';
import { EvolutionState, ChatMessage, SkillId, ChatSession, IMentorXContext, Source, EfficiencyStats, AppearanceSettings, Persona, Theme, WorkspaceState, CodeFile, ToolCall, ToolResponsePart, Task, TaskStep, AiWidget, User, Attachment, UiSettings, UserDataBundle } from '../types';
import { INITIAL_EVOLUTION_STATE, MENTORX_CORE_CACHE, MENTORX_PERSONAS, THEME_OPTIONS, MENTORX_MODES, SUPPORTED_LANGUAGES, COST_SAVER_SYSTEM_PROMPT_TOKEN_COUNT, ORIGINAL_SYSTEM_PROMPT_TOKEN_COUNT, resolvePersonaIcon } from '../constants';
import { streamMentorXResponse, generateMentorXImage, getAiCodeSuggestion, getWorkspaceAnalysis, generateTaskPlan, generateAiWidget, generatePromptForImageEditing, classifyPromptIntent } from '../services/geminiService';
import { getUserDataBundle, saveUserDataBundle } from '../services/firestoreService';
import { GenerateContentResponse, Part } from '@google/genai';

declare const google: any;

export const MentorXContext = createContext<IMentorXContext | undefined>(undefined);

const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
const approxTokens = (text: string) => Math.ceil((text || '').length / 4);

const DEFAULT_APPEARANCE: AppearanceSettings = {
    activeThemeId: 'default',
    customThemes: [],
    backgroundImage: '',
    backgroundOpacity: 20,
    customCss: '/* Your custom CSS rules will be applied here */\n',
};

const DEFAULT_UI_SETTINGS: UiSettings = {
    isSidebarCollapsed: false,
    showRightSidebar: true,
    showSidebar: true,
    dashboardWidgetIds: [],
};

const getLanguageFromFileName = (fileName: string): string => {
    const extension = '.' + fileName.split('.').pop();
    const lang = SUPPORTED_LANGUAGES.find(l => l.extensions.includes(extension?.toLowerCase() || ''));
    return lang ? lang.value : 'plaintext';
};

const DEFAULT_SANDBOX_WORKSPACE_STATE: WorkspaceState = {
    files: [
        { id: generateId(), name: 'index.html', language: 'html', code: `<!DOCTYPE html>
<html>
<head>
  <title>Code Sandbox</title>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <h1>Hello, Sandbox!</h1>
  <p>You can edit this file or ask the AI to build something for you.</p>
  <script type="module" src="./main.js"></script>
</body>
</html>` },
        { id: generateId(), name: 'main.js', language: 'javascript', code: `// Welcome to your Code Sandbox!
console.log("Hello from main.js!");

const app = document.createElement('div');
app.textContent = 'This content was generated by JavaScript.';
document.body.appendChild(app);
` },
        { id: generateId(), name: 'style.css', language: 'css', code: `body {
  font-family: sans-serif;
  background-color: #f0f0f0;
  color: #333;
}` },
    ],
    activeFileId: null,
    output: 'Welcome to the Code Sandbox! Ask the AI to build something, or hit "Run" to see your code in action.',
    previewHtml: null,
};

const DEFAULT_GAMEDEV_WORKSPACE_STATE: WorkspaceState = {
    files: [
         { id: generateId(), name: 'index.html', language: 'html', code: `<!DOCTYPE html>
<html>
<head>
  <title>Game Preview</title>
  <style>
    body { margin: 0; background: #111; display: flex; align-items-center; justify-content: center; height: 100vh; color: white; font-family: monospace; }
    canvas { border: 1px solid #333; background-color: #000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="480" height="320"></canvas>
  <script type="module" src="./main.js"></script>
</body>
</html>` },
        { id: generateId(), name: 'main.js', language: 'javascript', code: `// Main game loop and setup
import Player from './player.js';
import { log } from './utils.js';

log('Game starting...');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const player = new Player('Hero', canvas.width / 2, canvas.height / 2);

let angle = 0;

function gameLoop() {
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update player position
    player.x = canvas.width / 2 + Math.sin(angle) * 100;
    player.y = canvas.height / 2 + Math.cos(angle) * 100;
    angle += 0.02;

    // Draw player
    player.draw(ctx);

    requestAnimationFrame(gameLoop);
}

log('Game setup complete. Starting loop...');
gameLoop();
` },
        { id: generateId(), name: 'player.js', language: 'javascript', code: `// Player class
import { log } from './utils.js';

export default class Player {
    constructor(name, x, y) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.size = 20;
        this.color = 'cyan';
        log(\`Player \${this.name} created.\`);
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}
` },
        { id: generateId(), name: 'utils.js', language: 'javascript', code: `// Utility functions

export function log(message) {
    console.log(\`[GAME] - \${message}\`);
}
` },
    ],
    activeFileId: null,
    output: 'Welcome to the Game Dev Console! Hit "Run" to see your game.',
    previewHtml: null,
};

const decodeJwt = (token: string): User | null => {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        
        const decoded = JSON.parse(jsonPayload);
        return {
            id: decoded.sub,
            name: decoded.name,
            email: decoded.email,
            picture: decoded.picture,
        };
    } catch (e) {
        console.error("Error decoding JWT", e);
        return null;
    }
};

const DEFAULT_STATS: EfficiencyStats = { apiCallsAvoided: 0, tokensSaved: 0 };

export const MentorXProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // State
  const [user, setUser] = useState<User | null>(null);
  const [isUserDataLoading, setIsUserDataLoading] = useState(true);
  
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [evolutionState, setEvolutionState] = useState<EvolutionState>(INITIAL_EVOLUTION_STATE);
  const [stats, setStats] = useState<EfficiencyStats>(DEFAULT_STATS);
  const [customPersonas, setCustomPersonas] = useState<Persona[]>([]);
  const [customInstruction, setCustomInstruction] = useState('');
  
  const [appearanceSettings, setAppearanceSettings] = useState<AppearanceSettings>(DEFAULT_APPEARANCE);
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(DEFAULT_UI_SETTINGS.isSidebarCollapsed);
  const [showRightSidebar, setShowRightSidebar] = useState(DEFAULT_UI_SETTINGS.showRightSidebar);
  const [showSidebar, setShowSidebar] = useState(DEFAULT_UI_SETTINGS.showSidebar);
  const [dashboardWidgetIds, setDashboardWidgetIds] = useState<string[]>(DEFAULT_UI_SETTINGS.dashboardWidgetIds);

  const [isLoading, setIsLoading] = useState(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isLowFidelityMode, setIsLowFidelityMode] = useState(false);
  const [isCostSaverMode, setIsCostSaverMode] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');
  const [isCommandPaletteOpen, setIsCommandPaletteOpen] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isFocusMode, setIsFocusMode] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [isTutorialActive, setIsTutorialActive] = useState(false);
  const [tutorialStep, setTutorialStep] = useState(0);

  // Refs
  const stopGenerationRef = useRef(false);
  const initialLoadComplete = useRef(false);
  const saveTimeoutRef = useRef<number | null>(null);
  const recognitionRef = useRef<any>(null);

  // --- TUTORIAL MANAGEMENT ---
  const startTutorial = useCallback(() => {
    setTutorialStep(0);
    setIsTutorialActive(true);
  }, []);

  const endTutorial = useCallback(() => {
      setIsTutorialActive(false);
      localStorage.setItem('mentorx_tutorial_completed', 'true');
  }, []);

  const nextTutorialStep = useCallback(() => {
      setTutorialStep(prev => prev + 1);
  }, []);

  const prevTutorialStep = useCallback(() => {
      setTutorialStep(prev => Math.max(0, prev - 1));
  }, []);

  // --- AUTH & DATA LOADING ---

  const resetStateToDefault = useCallback(() => {
    setSessions([]);
    setActiveSessionId(null);
    setEvolutionState(INITIAL_EVOLUTION_STATE);
    setStats(DEFAULT_STATS);
    setCustomPersonas([]);
    setCustomInstruction('');
    setAppearanceSettings(DEFAULT_APPEARANCE);
    setIsSidebarCollapsed(DEFAULT_UI_SETTINGS.isSidebarCollapsed);
    setShowRightSidebar(DEFAULT_UI_SETTINGS.showRightSidebar);
    setShowSidebar(DEFAULT_UI_SETTINGS.showSidebar);
    setDashboardWidgetIds(DEFAULT_UI_SETTINGS.dashboardWidgetIds);
  }, []);

  const loadUserData = useCallback(async (userData: User) => {
    setIsUserDataLoading(true);
    const cloudData = await getUserDataBundle(userData);

    if (cloudData) {
        setSessions(cloudData.sessions || []);
        setCustomPersonas(cloudData.customPersonas || []);
        setAppearanceSettings(cloudData.appearanceSettings || DEFAULT_APPEARANCE);
        setCustomInstruction(cloudData.customInstruction || '');
        setEvolutionState(cloudData.evolutionState || INITIAL_EVOLUTION_STATE);
        setStats(cloudData.stats || DEFAULT_STATS);
        
        const uiSettings = cloudData.uiSettings || DEFAULT_UI_SETTINGS;
        setIsSidebarCollapsed(uiSettings.isSidebarCollapsed);
        setShowRightSidebar(uiSettings.showRightSidebar);
        setShowSidebar(uiSettings.showSidebar);
        setDashboardWidgetIds(uiSettings.dashboardWidgetIds);
    } else {
        resetStateToDefault();
    }

    setActiveSessionId(null);
    setIsUserDataLoading(false);
    initialLoadComplete.current = true;
  }, [resetStateToDefault]);

  useEffect(() => {
    const savedUser = localStorage.getItem('mentorx_user');
    
    const loadSequence = async (userData: User | null) => {
        if (userData) {
            await loadUserData(userData);
        } else {
            setIsUserDataLoading(false);
            initialLoadComplete.current = true;
        }
        
        // Use a timeout to ensure the UI is fully rendered before starting the tutorial
        setTimeout(() => {
            const tutorialCompleted = localStorage.getItem('mentorx_tutorial_completed') === 'true';
            if (!tutorialCompleted) {
                startTutorial();
            }
        }, 500);
    };
    
    if (savedUser) {
        const userData = JSON.parse(savedUser);
        setUser(userData);
        loadSequence(userData);
    } else {
        loadSequence(null);
    }
  }, [loadUserData, startTutorial]);


  const login = useCallback(async (credential: string) => {
    const userData = decodeJwt(credential);
    if (userData) {
      setUser(userData);
      localStorage.setItem('mentorx_user', JSON.stringify(userData));
      await loadUserData(userData);
    }
  }, [loadUserData]);

  const logout = useCallback(() => {
    if (typeof google !== 'undefined' && google.accounts?.id) {
        google.accounts.id.disableAutoSelect();
    }
    localStorage.removeItem('mentorx_user');
    setUser(null);
    resetStateToDefault();
    initialLoadComplete.current = false;
  }, [resetStateToDefault]);
  
  const saveData = useCallback(() => {
    if (!initialLoadComplete.current || !user || isUserDataLoading) return;

    setSaveStatus('saving');
    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

    saveTimeoutRef.current = window.setTimeout(async () => {
      const dataBundle: UserDataBundle = {
        sessions,
        customPersonas,
        appearanceSettings,
        customInstruction,
        uiSettings: {
          isSidebarCollapsed,
          showRightSidebar,
          showSidebar,
          dashboardWidgetIds,
        },
        evolutionState,
        stats,
      };
      try {
        await saveUserDataBundle(user, dataBundle);
        setSaveStatus('saved');
        setTimeout(() => setSaveStatus('idle'), 2000);
      } catch (error) {
        console.error("Failed to save data to cloud:", error);
        setSaveStatus('idle');
      }
    }, 1500);
  }, [
    user, isUserDataLoading, sessions, customPersonas, appearanceSettings, 
    customInstruction, isSidebarCollapsed, showRightSidebar, showSidebar, 
    dashboardWidgetIds, evolutionState, stats
  ]);

  useEffect(() => {
    if (user) {
      saveData();
    }
  }, [saveData, user]);


  // --- COMPUTED VALUES ---

  const activeSession = useMemo(() => sessions.find(s => s.id === activeSessionId), [sessions, activeSessionId]);
  
  const allPersonas = useMemo(() => [...MENTORX_PERSONAS, ...customPersonas], [customPersonas]);

  const activePersona = useMemo(() => {
      if (!activeSession) {
          const defaultPersona = MENTORX_PERSONAS[0];
          return { ...defaultPersona, icon: resolvePersonaIcon(defaultPersona.icon) };
      }
      const persona = allPersonas.find(p => p.id === activeSession.activePersonaId) || MENTORX_PERSONAS[0];
      return { ...persona, icon: resolvePersonaIcon(persona.icon) };
  }, [activeSession, allPersonas]);
  
  const theme = useMemo(() => {
      const allThemes = [...THEME_OPTIONS, ...appearanceSettings.customThemes];
      return allThemes.find(t => t.id === appearanceSettings.activeThemeId) || THEME_OPTIONS[0];
  }, [appearanceSettings.activeThemeId, appearanceSettings.customThemes]);

  const isPremiumUser = !!user;

  // --- SESSION/CHAT MANAGEMENT ---
  
  const startNewChat = useCallback((personaId: string = 'default') => {
    const persona = allPersonas.find(p => p.id === personaId) || MENTORX_PERSONAS[0];
    
    const newSession: ChatSession = {
      id: generateId(),
      title: persona.name,
      messages: [],
      modeId: 'mentor',
      isWebAccessEnabled: false,
      isDeepAnalysis: false,
      createdAt: new Date(),
      totalTokens: 0,
      activePersonaId: persona.id,
      temperature: 0.7,
      topP: 0.95,
      topK: undefined,
      widgets: [],
      activeWidgetId: null,
    };

    if (personaId === 'gamedev' || personaId === 'sandbox') {
        const defaultState = personaId === 'gamedev' ? DEFAULT_GAMEDEV_WORKSPACE_STATE : DEFAULT_SANDBOX_WORKSPACE_STATE;
        newSession.workspaceState = {
            ...defaultState,
            files: defaultState.files.map(f => ({ ...f, id: generateId() })),
            activeFileId: null
        };
    }
    
    if (personaId === 'widget_factory') {
        newSession.title = "New Widget Session";
    }

    setSessions(prev => [newSession, ...prev]);
    setActiveSessionId(newSession.id);
  }, [allPersonas]);
  
  const deleteChat = useCallback((sessionId: string) => {
    setSessions(prev => prev.filter(s => s.id !== sessionId));
    if (activeSessionId === sessionId) {
      setActiveSessionId(null);
    }
  }, [activeSessionId]);

  const renameChat = useCallback((sessionId: string, newTitle: string) => {
    setSessions(prev => prev.map(s => s.id === sessionId ? { ...s, title: newTitle } : s));
  }, []);

  const exportChat = useCallback((sessionId: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session) return;
    const content = session.messages.map(m => `**${m.role.toUpperCase()}**: ${m.text}`).join('\n\n');
    const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${session.title.replace(/ /g, '_')}.md`;
    link.click();
  }, [sessions]);

  // --- AI INTERACTION ---
  
  const stopGeneration = useCallback(() => {
      stopGenerationRef.current = true;
  }, []);

  const updateSession = useCallback((sessionId: string, updates: Partial<ChatSession> | ((session: ChatSession) => Partial<ChatSession>)) => {
    setSessions(prev => prev.map(s => {
        if (s.id === sessionId) {
            const changes = typeof updates === 'function' ? updates(s) : updates;
            return { ...s, ...changes };
        }
        return s;
    }));
  }, []);

  const _sendMessageInternal = useCallback(async (
    sessionId: string, 
    history: ChatMessage[],
    boosted: boolean = false,
  ) => {
      const session = sessions.find(s => s.id === sessionId);
      const persona = allPersonas.find(p => p.id === session?.activePersonaId) || MENTORX_PERSONAS[0];
      if (!session || !persona) return;
      
      setIsLoading(true);
      stopGenerationRef.current = false;

      const assistantMessageId = generateId();
      const assistantMessage: ChatMessage = { id: assistantMessageId, role: 'assistant', text: '', timestamp: new Date(), toolCalls: [], };

      updateSession(sessionId, { messages: [...history, assistantMessage] });
      
      const processStream = async (streamHistory: ChatMessage[]) => {
          try {
              const stream = streamMentorXResponse(
                streamHistory, 
                persona, 
                session.isWebAccessEnabled, 
                isCostSaverMode, 
                session.isDeepAnalysis || boosted,
                customInstruction, 
                { temperature: session.temperature, topP: session.topP, topK: session.topK }
              );

              let textResponse = '';
              let toolCalls: ToolCall[] = [];
              let lastChunk: GenerateContentResponse | undefined;

              for await (const chunk of stream) {
                  if (stopGenerationRef.current) break;
                  
                  if (chunk.text) {
                      textResponse += chunk.text;
                      updateSession(sessionId, s => ({
                          messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: textResponse } : m)
                      }));
                  }
                  
                  // Backend is not yet configured to send tool calls, this is a placeholder
                  // const functionCallsFromChunk = chunk.functionCalls;
                  
                  lastChunk = chunk;
              }

              const finalAssistantMsg: Partial<ChatMessage> = { text: textResponse, toolCalls: toolCalls.length > 0 ? toolCalls : undefined };
              if (lastChunk?.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                finalAssistantMsg.sources = lastChunk.candidates[0].groundingMetadata.groundingChunks
                    .map((c: any) => c.web).filter((c: any) => c?.uri && c?.title);
              }
              const finalTokens = approxTokens(textResponse);
              finalAssistantMsg.tokens = finalTokens;
              updateSession(sessionId, s => ({ 
                totalTokens: (s.totalTokens || 0) + finalTokens,
                messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, ...finalAssistantMsg } : m)
              }));

              if (toolCalls.length > 0 && !stopGenerationRef.current) {
                  // Tool call execution logic would go here
              }
          } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
              updateSession(sessionId, s => ({
                  messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: `Error: ${errorMessage}` } : m)
              }));
          }
      };

      await processStream(history);

      setIsLoading(false);
  }, [sessions, allPersonas, isCostSaverMode, customInstruction, updateSession]);
  
  const executeTask = useCallback(async (sessionId: string, goal: string) => {
      const session = sessions.find(s => s.id === sessionId);
      if (!session) return;

      const initialTask: Task = {
          id: generateId(),
          goal,
          plan: [],
          status: 'planning',
      };
      
      const userGoalMessage: ChatMessage = {id: generateId(), role: 'user', text: `/execute ${goal}`, timestamp: new Date()};
      const currentMessages = [...session.messages, userGoalMessage];
      updateSession(sessionId, { messages: currentMessages, activeTask: initialTask });
      
      try {
          const planSteps = await generateTaskPlan(goal);
          const taskPlan: TaskStep[] = planSteps.map(step => ({
              id: generateId(),
              description: step.description,
              status: 'pending',
          }));
          updateSession(sessionId, s => ({ activeTask: { ...s.activeTask!, plan: taskPlan, status: 'in-progress' }}));
          
          const executionKickoffMessage: ChatMessage = {
              id: generateId(),
              role: 'user',
              text: `My goal is: "${goal}". You have generated this plan:\n${taskPlan.map((s, i) => `${i+1}. ${s.description}`).join('\n')}\n\nPlease start executing the first step. Use the available tools.`,
              timestamp: new Date()
          };
          
          const executionHistory = [...currentMessages, executionKickoffMessage];

          await _sendMessageInternal(sessionId, executionHistory);

          updateSession(sessionId, s => ({ activeTask: { ...s.activeTask!, status: 'completed' } }));

      } catch (error) {
          console.error("Task execution failed:", error);
          const errorMessage = error instanceof Error ? error.message : "Failed to generate a plan.";
          updateSession(sessionId, s => ({ activeTask: { ...s.activeTask!, status: 'failed', error: errorMessage } }));
      }
  }, [sessions, updateSession, _sendMessageInternal]);

  const performAiCodeAction = useCallback(async (sessionId: string, action: 'refactor' | 'debug' | 'document' | 'explain' | 'test' | 'analyze') => {
      const session = sessions.find(s => s.id === sessionId);
      if (!session?.workspaceState) return;
      
      setIsLoading(true);
      const assistantMessageId = generateId();
      const assistantMessage: ChatMessage = { id: assistantMessageId, role: 'assistant', text: `Performing action: ${action}...`, timestamp: new Date() };
      updateSession(sessionId, { messages: [...session.messages, assistantMessage] });
  
      try {
          let responseText = '';
          if (action === 'analyze') {
              const fileList = session.workspaceState.files.map(f => f.name);
              const suggestions = await getWorkspaceAnalysis(fileList);
              responseText = `**Workspace Analysis Complete:**\n\n* ${suggestions.join('\n* ')}`;
          } else {
              const activeFile = session.workspaceState.files.find(f => f.id === session.workspaceState?.activeFileId);
              if (!activeFile) {
                  responseText = "Error: No active file selected to perform the action on.";
              } else {
                  responseText = await getAiCodeSuggestion(activeFile.code, activeFile.language, action);
              }
          }
          updateSession(sessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: responseText } : m) }));
      } catch(error) {
          const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during the AI code action.";
          updateSession(sessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessageId ? { ...m, text: `Error: ${errorMessage}` } : m) }));
      } finally {
          setIsLoading(false);
      }
  }, [sessions, updateSession]);
  
  const sendMessage = useCallback(async (prompt: string, attachment: Attachment | null = null, options: { aspectRatio?: string, numberOfImages?: number } = {}, boosted: boolean = false) => {
      if (!activeSessionId) return;

      if(prompt.toLowerCase().startsWith('/execute ')){
          const goal = prompt.substring(9).trim();
          executeTask(activeSessionId, goal);
          return;
      }
      if(prompt.toLowerCase().trim() === '/analyze'){
        performAiCodeAction(activeSessionId, 'analyze');
        return;
      }

      const session = sessions.find(s => s.id === activeSessionId);
      if (!session) return;
      
      // All AI image generation now goes through the backend
      if (options.aspectRatio || (attachment && prompt && attachment.type.startsWith('image/')) || await classifyPromptIntent(prompt) === 'image_generation') {
          setIsLoading(true);
          const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date(), attachment: attachment ?? undefined };
          const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: "Generating your image(s)...", timestamp: new Date() };
          updateSession(activeSessionId, s => ({ messages: [...s.messages, userMessage, assistantMessage] }));

          try {
              const finalPrompt = attachment ? await generatePromptForImageEditing(prompt, { data: attachment.data, mimeType: attachment.type }) : prompt;
              const imageUrls = await generateMentorXImage(finalPrompt, options.aspectRatio, options.numberOfImages);

              const [header, data] = imageUrls[0].split(',');
              const mimeType = header.match(/:(.*?);/)?.[1] || 'image/jpeg';
              const imgAttachment: Attachment = { name: "generated-image.jpg", type: mimeType, data: data, size: data.length };
              updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Here is the image you requested:`, attachment: imgAttachment } : m) }));
          } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during image generation.";
              updateSession(activeSessionId, s => ({ messages: s.messages.map(m => m.id === assistantMessage.id ? { ...m, text: `Error: ${errorMessage}` } : m) }));
          } finally {
              setIsLoading(false);
          }
          return;
      }

      const cacheKey = prompt.toLowerCase().trim();
      if (MENTORX_CORE_CACHE.has(cacheKey) && !session.isWebAccessEnabled) {
          const cachedResponse = MENTORX_CORE_CACHE.get(cacheKey)!;
          const userMessage: ChatMessage = { id: generateId(), role: 'user', text: prompt, timestamp: new Date() };
          const assistantMessage: ChatMessage = { id: generateId(), role: 'assistant', text: cachedResponse, timestamp: new Date(), isCached: true };
          updateSession(activeSessionId, { messages: [...session.messages, userMessage, assistantMessage] });
          setStats(s => ({ ...s, apiCallsAvoided: s.apiCallsAvoided + 1, tokensSaved: s.tokensSaved + approxTokens(cachedResponse) }));
          return;
      }
      
      const userMessage: ChatMessage = {
          id: generateId(), role: 'user', text: prompt, timestamp: new Date(),
          attachment: attachment || undefined,
      };

      const newHistory = [...session.messages, userMessage];
      updateSession(activeSessionId, { messages: newHistory });
      await _sendMessageInternal(activeSessionId, newHistory, boosted);

  }, [activeSessionId, sessions, _sendMessageInternal, updateSession, executeTask, performAiCodeAction]);

  const editMessage = useCallback(async (sessionId: string, messageId: string, newText: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session) return;
    
    const messageIndex = session.messages.findIndex(m => m.id === messageId);
    if (messageIndex === -1 || session.messages[messageIndex].role !== 'user') return;

    const historyUpToEdit = session.messages.slice(0, messageIndex);
    const editedMessage: ChatMessage = { ...session.messages[messageIndex], text: newText };
    const newHistory = [...historyUpToEdit, editedMessage];

    updateSession(sessionId, { messages: newHistory, activeTask: null });
    await _sendMessageInternal(sessionId, newHistory);
  }, [sessions, _sendMessageInternal, updateSession]);

  const regenerateLastResponse = useCallback(async (sessionId: string) => {
    const session = sessions.find(s => s.id === sessionId);
    if (!session || session.messages.length === 0) return;

    let lastUserMessageIndex = -1;
    for (let i = session.messages.length - 1; i >= 0; i--) {
        if (session.messages[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    if (lastUserMessageIndex === -1) return;

    const newHistory = session.messages.slice(0, lastUserMessageIndex + 1);
    
    updateSession(sessionId, { messages: newHistory, activeTask: null });
    await _sendMessageInternal(sessionId, newHistory);
  }, [sessions, _sendMessageInternal, updateSession]);

  // --- WORKSPACE & CODECANVAS ---
  
  const executeToolCalls = async (toolCalls: ToolCall[], sessionId: string): Promise<ToolResponsePart[]> => {
    // This now needs to be proxied to the backend, placeholder for now
    console.warn("Tool calls are not yet implemented with the backend.");
    return [];
  };
  
  const updateWorkspaceState = (sessionId: string, updates: Partial<WorkspaceState>) => {
      updateSession(sessionId, s => ({ workspaceState: { ...s.workspaceState!, ...updates }}));
  };
  
  const addCodeFile = useCallback((sessionId: string, fileName: string, code: string = '') => {
      const newFile: CodeFile = { id: generateId(), name: fileName, code, language: getLanguageFromFileName(fileName) };
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          return { workspaceState: { ...ws, files: [...ws.files, newFile], activeFileId: newFile.id }};
      });
  }, [updateSession]);
  
  const deleteCodeFile = useCallback((sessionId: string, fileId: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.filter(f => f.id !== fileId);
          const newActiveFileId = ws.activeFileId === fileId ? (newFiles[0]?.id || null) : ws.activeFileId;
          return { workspaceState: { ...ws, files: newFiles, activeFileId: newActiveFileId } };
      });
  }, [updateSession]);
  
  const renameCodeFile = useCallback((sessionId: string, fileId: string, newName: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.map(f => f.id === fileId ? { ...f, name: newName, language: getLanguageFromFileName(newName) } : f);
          return { workspaceState: { ...ws, files: newFiles }};
      });
  }, [updateSession]);
  
  const setActiveCodeFile = useCallback((sessionId: string, fileId: string | null) => {
      updateWorkspaceState(sessionId, { activeFileId: fileId });
  }, []);
  
  const updateCodeFile = useCallback((sessionId: string, fileId: string, newCode: string, newLanguage?: string) => {
      updateSession(sessionId, s => {
          const ws = s.workspaceState!;
          const newFiles = ws.files.map(f => f.id === fileId ? { ...f, code: newCode, language: newLanguage || f.language } : f);
          return { workspaceState: { ...ws, files: newFiles }};
      });
  }, [updateSession]);

  const runCode = useCallback(async (sessionId: string) => {
      const session = sessions.find(s => s.id === sessionId);
      if (!session?.workspaceState) return;

      updateWorkspaceState(sessionId, { output: '> Running project...\n' });

      const { files } = session.workspaceState;
      const htmlFile = files.find(f => f.name.endsWith('.html'));
      if (!htmlFile) {
          updateWorkspaceState(sessionId, { output: (session.workspaceState.output || '') + '> Error: No index.html file found.\n' });
          return;
      }

      let doc = new DOMParser().parseFromString(htmlFile.code, 'text/html');
      const blobUrls = new Map<string, string>();
      const importMap: { imports: Record<string, string> } = { imports: {} };

      // Process CSS
      doc.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
          const htmlLink = link as HTMLLinkElement;
          const href = htmlLink.getAttribute('href')!;
          const cssFile = files.find(f => `./${f.name}` === href);
          if (cssFile) {
              const blob = new Blob([cssFile.code], { type: 'text/css' });
              const url = URL.createObjectURL(blob);
              htmlLink.href = url;
              blobUrls.set(url, '');
          }
      });
      
      const loggerScript = `
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        console.log = (...args) => { window.parent.postMessage({ type: 'log', message: args.join(' ') }, '*'); originalLog(...args); };
        console.warn = (...args) => { window.parent.postMessage({ type: 'warn', message: args.join(' ') }, '*'); originalWarn(...args); };
        console.error = (...args) => { window.parent.postMessage({ type: 'error', message: args.join(' ') }, '*'); originalError(...args); };
        window.addEventListener('error', event => { console.error(event.message); });
      `;
      const loggerScriptEl = doc.createElement('script');
      loggerScriptEl.textContent = loggerScript;
      doc.head.insertBefore(loggerScriptEl, doc.head.firstChild);

      // Process JS
      for (const file of files.filter(f => f.language === 'javascript')) {
          const blob = new Blob([file.code], { type: 'application/javascript' });
          const url = URL.createObjectURL(blob);
          blobUrls.set(url, '');
          importMap.imports[`./${file.name}`] = url;
          importMap.imports[file.name] = url;
      }

      const importMapScript = doc.createElement('script');
      importMapScript.type = 'importmap';
      importMapScript.textContent = JSON.stringify(importMap);
      doc.head.appendChild(importMapScript);

      const finalHtml = new XMLSerializer().serializeToString(doc);
      updateWorkspaceState(sessionId, { previewHtml: finalHtml });

      // Clean up blob URLs after a delay
      setTimeout(() => {
          blobUrls.forEach((_, url) => URL.revokeObjectURL(url));
      }, 30000);
  }, [sessions]);

  const appendOutput = useCallback((sessionId: string, message: string) => {
      updateWorkspaceState(sessionId, { output: (activeSession?.workspaceState?.output || '') + message + '\n' });
  }, [activeSession]);

  const uploadWorkspace = useCallback(async (sessionId: string) => {
      alert("Conceptual Feature: In a real app, this would open a file dialog to select a project folder. The files would then be read and added to the workspace.");
  }, []);

  const resetWorkspace = useCallback((sessionId: string) => {
      if (window.confirm("Are you sure you want to reset the workspace to its default state? All changes will be lost.")) {
         const personaId = sessions.find(s => s.id === sessionId)?.activePersonaId;
         const defaultState = personaId === 'gamedev' ? DEFAULT_GAMEDEV_WORKSPACE_STATE : DEFAULT_SANDBOX_WORKSPACE_STATE;
         updateWorkspaceState(sessionId, {
              ...defaultState,
              files: defaultState.files.map(f => ({ ...f, id: generateId() })),
              activeFileId: null
         });
      }
  }, [sessions]);

  // --- WIDGET FACTORY ---
  const clearWidgets = useCallback((sessionId: string) => {
      updateSession(sessionId, { widgets: [], activeWidgetId: null });
  }, [updateSession]);

  const deleteWidget = useCallback((sessionId: string, widgetId: string) => {
      updateSession(sessionId, s => {
          const newWidgets = s.widgets?.filter(w => w.id !== widgetId) || [];
          const newActiveId = s.activeWidgetId === widgetId ? newWidgets[0]?.id || null : s.activeWidgetId;
          return { widgets: newWidgets, activeWidgetId: newActiveId };
      });
  }, [updateSession]);

  const setActiveWidgetId = useCallback((sessionId: string, widgetId: string | null) => {
      updateSession(sessionId, { activeWidgetId: widgetId });
  }, [updateSession]);

  const generateAndAddWidget = useCallback(async (sessionId: string, prompt: string) => {
      setIsLoading(true);
      try {
          const jsx = await generateAiWidget(prompt);
          const newWidget: AiWidget = {
              id: generateId(),
              prompt,
              jsx,
              lastUpdatedAt: new Date(),
          };
          updateSession(sessionId, s => {
              const widgets = [...(s.widgets || []), newWidget];
              return { widgets, activeWidgetId: newWidget.id };
          });
      } catch (error) {
          console.error("Failed to generate widget:", error);
      } finally {
          setIsLoading(false);
      }
  }, [updateSession]);
  
  // --- SETTINGS & MISC ---
  const toggleLowFidelityMode = useCallback(() => setIsLowFidelityMode(p => !p), []);
  const toggleCostSaverMode = useCallback(() => setIsCostSaverMode(p => !p), []);
  const toggleSessionWebAccess = useCallback((sessionId: string) => updateSession(sessionId, s => ({ isWebAccessEnabled: !s.isWebAccessEnabled })), [updateSession]);
  const toggleSessionDeepAnalysis = useCallback((sessionId: string) => updateSession(sessionId, s => ({ isDeepAnalysis: !s.isDeepAnalysis })), [updateSession]);
  
  const addCustomPersona = useCallback((persona: Omit<Persona, 'id' | 'isCustom' | 'isPro'>) => {
      const newPersona: Persona = {
          ...persona,
          id: `custom_${generateId()}`,
          isCustom: true,
          isPro: false, // Custom personas are always available
      };
      setCustomPersonas(prev => [...prev, newPersona]);
  }, []);
  
  const updateCustomPersona = useCallback((persona: Persona) => {
      setCustomPersonas(prev => prev.map(p => p.id === persona.id ? persona : p));
  }, []);
  
  const deleteCustomPersona = useCallback((personaId: string) => {
      setCustomPersonas(prev => prev.filter(p => p.id !== personaId));
  }, []);
  
  const updateAppearanceSettings = useCallback((settings: Partial<AppearanceSettings>) => {
    setAppearanceSettings(prev => ({ ...prev, ...settings }));
  }, []);
  
  const addCustomTheme = useCallback((theme: Omit<Theme, 'id' | 'isCustom' | 'isPro'>) => {
    const newTheme: Theme = { ...theme, id: `custom_${generateId()}`, isCustom: true, isPro: false };
    setAppearanceSettings(prev => ({...prev, customThemes: [...prev.customThemes, newTheme]}));
  }, []);

  const updateCustomTheme = useCallback((theme: Theme) => {
      setAppearanceSettings(prev => ({...prev, customThemes: prev.customThemes.map(t => t.id === theme.id ? theme : t)}));
  }, []);

  const deleteCustomTheme = useCallback((themeId: string) => {
      setAppearanceSettings(prev => ({...prev, customThemes: prev.customThemes.filter(t => t.id !== themeId)}));
  }, []);

  const setSessionPersona = useCallback((sessionId: string, personaId: string) => {
      updateSession(sessionId, { activePersonaId: personaId });
  }, [updateSession]);

  const setSessionModelParams = useCallback((sessionId: string, params: { temperature?: number, topP?: number, topK?: number }) => {
      updateSession(sessionId, { ...params });
  }, [updateSession]);

  const startRecording = useCallback(() => {
      const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
      if (!SpeechRecognition) {
          alert("Sorry, your browser doesn't support speech recognition.");
          return;
      }
      const recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.onstart = () => setIsRecording(true);
      recognition.onend = () => setIsRecording(false);
      recognition.onresult = (event: any) => {
          // This part could be used for live transcription preview if needed
      };
      recognition.start();
      recognitionRef.current = recognition;
  }, []);
  
  const stopRecording = useCallback((): Promise<string | undefined> => {
      return new Promise(resolve => {
        if (recognitionRef.current) {
            recognitionRef.current.onresult = (event: any) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    }
                }
                resolve(finalTranscript.trim());
            };
            recognitionRef.current.stop();
            setIsRecording(false);
        } else {
            resolve(undefined);
        }
      });
  }, []);

  const addWidgetToDashboard = useCallback((widgetId: string) => {
      setDashboardWidgetIds(prev => [...new Set([...prev, widgetId])]);
  }, []);

  const removeWidgetFromDashboard = useCallback((widgetId: string) => {
      setDashboardWidgetIds(prev => prev.filter(id => id !== widgetId));
  }, []);
    
const contextValue = useMemo<IMentorXContext>(() => ({
    sessions,
    activeSessionId,
    activeSession,
    evolutionState,
    isLoading,
    isLowFidelityMode,
    isCostSaverMode,
    stats,
    isPremiumUser,
    searchQuery,
    customInstruction,
    isSidebarOpen,
    isSidebarCollapsed,
    saveStatus,
    appearanceSettings,
    theme,
    activePersona,
    customPersonas,
    showRightSidebar,
    showSidebar,
    isCommandPaletteOpen,
    isSettingsOpen,
    isFocusMode,
    isRecording,
    dashboardWidgetIds,
    user,
    isUserDataLoading,
    isTutorialActive,
    tutorialStep,
    startTutorial,
    nextTutorialStep,
    prevTutorialStep,
    endTutorial,
    login,
    logout,
    addWidgetToDashboard,
    removeWidgetFromDashboard,
    startRecording,
    stopRecording,
    setIsCommandPaletteOpen,
    setIsSettingsOpen,
    setIsFocusMode,
    setShowRightSidebar,
    setShowSidebar,
    addCustomPersona,
    updateCustomPersona,
    deleteCustomPersona,
    setAppearanceSettings: updateAppearanceSettings,
    addCustomTheme,
    updateCustomTheme,
    deleteCustomTheme,
    setSessionPersona,
    setSessionModelParams,
    setIsSidebarOpen,
    setIsSidebarCollapsed,
    setCustomInstruction,
    setSearchQuery,
    toggleLowFidelityMode,
    toggleCostSaverMode,
    startNewChat,
    deleteChat,
    renameChat,
    setActiveSessionId,
    sendMessage,
    editMessage,
    regenerateLastResponse,
    toggleSessionWebAccess,
    toggleSessionDeepAnalysis,
    exportChat,
    stopGeneration,
    addCodeFile,
    deleteCodeFile,
    renameCodeFile,
    setActiveCodeFile,
    updateCodeFile,
    runCode,
    appendOutput,
    performAiCodeAction,
    executeTask,
    uploadWorkspace,
    resetWorkspace,
    clearWidgets,
    deleteWidget,
    setActiveWidgetId,
    generateAndAddWidget,
  }), [
      sessions, activeSessionId, activeSession, evolutionState, isLoading, isLowFidelityMode, isCostSaverMode,
      stats, isPremiumUser, searchQuery, customInstruction, isSidebarOpen, isSidebarCollapsed, saveStatus,
      appearanceSettings, theme, activePersona, customPersonas, showRightSidebar, showSidebar, isCommandPaletteOpen,
      isSettingsOpen, isFocusMode, isRecording, dashboardWidgetIds, user, isUserDataLoading, isTutorialActive,
      tutorialStep, startTutorial, nextTutorialStep, prevTutorialStep, endTutorial, login, logout, addWidgetToDashboard,
      removeWidgetFromDashboard, startRecording, stopRecording, addCustomPersona, updateCustomPersona, deleteCustomPersona,
      updateAppearanceSettings, addCustomTheme, updateCustomTheme, deleteCustomTheme, setSessionPersona, setSessionModelParams,
      setCustomInstruction, setSearchQuery, toggleLowFidelityMode, toggleCostSaverMode, startNewChat, deleteChat,
      renameChat, setActiveSessionId, sendMessage, editMessage, regenerateLastResponse, toggleSessionWebAccess,
      toggleSessionDeepAnalysis, exportChat, stopGeneration, addCodeFile, deleteCodeFile, renameCodeFile,
      setActiveCodeFile, updateCodeFile, runCode, appendOutput, performAiCodeAction, executeTask, uploadWorkspace,
      resetWorkspace, clearWidgets, deleteWidget, setActiveWidgetId, generateAndAddWidget
  ]);

  return (
      <MentorXContext.Provider value={contextValue}>
          {children}
      </MentorXContext.Provider>
  );
};
